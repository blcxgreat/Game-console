
//=======================================================
//  This code is generated by Terasic System Builder
//=======================================================

// Controls:
// KEY[2]: reset the system.
// KEY[3]: Run the autofocus system.
// SW[9]: Choose between full and central auto-focus, plus yellow rectangle.

module DE1_SOC_D8M_RTL(

	//////////// ADC //////////
	output		          		ADC_CONVST,
	output		          		ADC_DIN,
	input 		          		ADC_DOUT,
	output		          		ADC_SCLK,

	//////////// Audio //////////
	input 		          		AUD_ADCDAT,
	inout 		          		AUD_ADCLRCK,
	inout 		          		AUD_BCLK,
	output		          		AUD_DACDAT,
	inout 		          		AUD_DACLRCK,
	output		          		AUD_XCK,	
	
	//////////// CLOCK //////////
	input 		          		CLOCK2_50,
	input 		          		CLOCK3_50,
	input 		          		CLOCK4_50,
	input 		          		CLOCK_50,

	//////////// SDRAM //////////
	output		    [12:0]		DRAM_ADDR,
	output		    [1:0]		DRAM_BA,
	output		          		DRAM_CAS_N,
	output		          		DRAM_CKE,
	output		          		DRAM_CLK,
	output		          		DRAM_CS_N,
	inout 		    [15:0]		DRAM_DQ,
	output		          		DRAM_LDQM,
	output		          		DRAM_RAS_N,
	output		          		DRAM_UDQM,
	output		          		DRAM_WE_N,

	//////////// I2C for Audio and Video-In //////////
	output		          		FPGA_I2C_SCLK,
	inout 		          		FPGA_I2C_SDAT,	
	
	//////////// SEG7 //////////
	output		     [6:0]		HEX0,
	output		     [6:0]		HEX1,
	output		     [6:0]		HEX2,
	output		     [6:0]		HEX3,
	output		     [6:0]		HEX4,
	output		     [6:0]		HEX5,

	//////////// IR //////////
	input 		          		IRDA_RXD,
	output		          		IRDA_TXD,

	//////////// KEY //////////
	input 		     [3:0]		KEY,

	//////////// LED //////////
	output		     [9:0]		LEDR,

	//////////// PS2 //////////
	inout 		          		PS2_CLK,
	inout 		          		PS2_CLK2,
	inout 		          		PS2_DAT,
	inout 		          		PS2_DAT2,	
	
	//////////// SW //////////
	input 		     [9:0]		SW,

	//////////// Video-In //////////
	input 		          		TD_CLK27,
	input 		     [7:0]		TD_DATA,
	input 		          		TD_HS,
	output		          		TD_RESET_N,
	input 		          		TD_VS,

	//////////// VGA //////////
	output		          		VGA_BLANK_N,
	output		     [7:0]		VGA_B,
	output		          		VGA_CLK,
	output		     [7:0]		VGA_G,
	output		          		VGA_HS,
	output		     [7:0]		VGA_R,
	output		          		VGA_SYNC_N,
	output		          		VGA_VS,

	//////////// GPIO_1, GPIO_1 connect to D8M-GPIO //////////
	output 		          		CAMERA_I2C_SCL,
	inout 		          		CAMERA_I2C_SDA,
	output		          		CAMERA_PWDN_n,
	output		          		MIPI_CS_n,
	inout 		          		MIPI_I2C_SCL,
	inout 		          		MIPI_I2C_SDA,
	output		          		MIPI_MCLK,
	input 		          		MIPI_PIXEL_CLK,
	input 		     [9:0]		MIPI_PIXEL_D,
	input 		          		MIPI_PIXEL_HS,
	input 		          		MIPI_PIXEL_VS,
	output		          		MIPI_REFCLK,
	output		          		MIPI_RESET_n,
	//////////// GPIO_0, GPIO_0 connect to GPIO Default //////////
	inout 		    [35:0]		GPIO 	
	
);

//MUSIC
part2 music (CLOCK_50, CLOCK2_50, reset || stopmusic, FPGA_I2C_SCLK, FPGA_I2C_SDAT, AUD_XCK, 
		        AUD_DACLRCK, AUD_ADCLRCK, AUD_BCLK, AUD_ADCDAT, AUD_DACDAT);

	logic start;
	assign start = SW[8];
	logic reset;
	assign reset = SW[9];
	logic gch;
	assign gch = SW[7];
	logic [2:0] cut, cnt;
	logic [6:0] sta, lev, n, psl, psm, psr;
	logic [6:0] hex0, hex1, hex2, hex3, hex4, hex5;
	// Generate clk off of CLOCK_50, whichClock picks rate.
	logic [31:0] clock;
	parameter whichClock = 14;
	clock_divider cdiv (CLOCK_50, clock);
	assign clk = clock[whichClock];
   
	logic [3:0] keyboard;

	
	// GAME controller
	enum {ini, gameselect, gc, gf, gameover} ps, ns;
	
	always_ff @(posedge clk)
		if (reset) ps <= ini;
		else ps <= ns;
		
	always_comb begin
		case(ps)
			ini: if (start) ns = gameselect;
				  else ns = ini;
			gameselect: if (gch) ns = gc;
							else ns = gf;
			gc: if (~gch) ns = gameover;
				 else ns = gc;
			gf: if (gch) ns = gameover;
				 else ns = gf;
			gameover: if (start) ns = gameover;
						 else ns = ini;
			default: ns = ini;
		endcase	
	end
	// control signals
	logic playcart, playsnake, stopcart, stopsnake, playmusic, encamera, holdreset, stopmusic;
	
	assign holdreset = (ps == ini || ps == gameselect);
	assign playcart = (ps == gc);
	assign playsnake = (ps == gf);
	assign stopmusic = (ps == gameover || ps == ini || ps == gameselect);
	assign encamera = (ps == gameover);                                                                                                                  
	
	logic [7:0][7:0] red_arrayl, green_arrayc, red_arrayr, p1drive, p2drive, common, score, green, body;
	
	logic [7:0][7:0] temp;
	assign temp = (score | body);
	
	always_comb begin
		if (playcart) begin
			p1drive = red_arrayl;
			p2drive = red_arrayr;
			common = green_arrayc;
			HEX5 = sta;
			HEX4 = lev;
			HEX3 = n;
			HEX2 = psl;
			HEX1 = psm;
			HEX0 = psr;		
		end else if (playsnake) begin
			p1drive = temp; 
			p2drive = temp; 
			common = green;
			HEX5 = hex5;
			HEX4 = hex4;
			HEX3 = hex3;
			HEX2 = hex2;
			HEX1 = hex1;
			HEX0 = hex0; 
      end else begin
			p1drive = 0; 
			p2drive = 0; 
			common = 0;
			HEX5 = 7'b1111111;
			HEX4 = 7'b1111111;
			HEX3 = 7'b1111111;
			HEX2 = 7'b1111111;
			HEX1 = 7'b1111111;
			HEX0 = 7'b1111111;
		end
		
		
	end
   
	// Converting from keyboard output to game input
   logic valid;
	logic makeBreak;
	logic [7:0] outCode;
	logic pressUp, pressLeft, pressDown, pressRight;
	
	keyboard_press_driver key1(
		.CLOCK_50(CLOCK_50), 
		.valid(valid), 
		.makeBreak(makeBreak),
		.outCode(outCode),
		.PS2_DAT(PS2_DAT), 
		.PS2_CLK(PS2_CLK), 
		.reset(reset)
   ); 
	
	assign pressUp = (outCode == 8'h6C)? 1 : 0;
	assign pressLeft = (outCode == 8'h71)? 1 : 0;
	assign pressDown = (outCode == 8'h69)? 1 : 0;
	assign pressRight = (outCode == 8'h7A)? 1 : 0;
	assign keyboard = {pressLeft, pressRight, pressUp, pressDown};
    
	 
	 //GAME OF CART
		game_of_cart 
c1(.clk, .reset(holdreset || SW[6]), .levelS(SW[2:0]), .p1L(~KEY[3]), .p1R(~KEY[2]), .p2L(pressLeft), .p2R(pressRight), .red_arrayl, .green_arrayc, .red_arrayr, .LED(), .stage(sta), .level(lev), .num(n), .pscorel(psl), .pscorem(psm), .pscorer(psr), .bom(SW[5]));
  
    //GAME OF SNAKE
	 Snake c2 (.CLOCK_50(CLOCK_50), .reset(holdreset || SW[6]), .HEX0(hex0), .HEX1(hex1), .HEX2(hex2), .HEX3(hex3), .HEX4(hex4), .HEX5(hex5), .KEY(KEY), .LEDR(LEDR), .SW(SW), .score_array(score), .green_array(green), .body_array(body), .count(cut), .press(keyboard));



	led_matrix_driver playerl (.clk, .reset(holdreset || SW[6]), .red_array(p1drive), .green_array(common), .red_driver(GPIO[27:20]), .green_driver(GPIO[35:28]), .row_sink(GPIO[19:12]), .count(cut));		
	led_matrix_driver playerr (.clk, .reset(holdreset || SW[6]), .red_array(p2drive), .green_array(common), .red_driver(GPIO[11:4]), .green_driver(), .row_sink(), .count(cnt));
 
	
	
	
	
// Camera	
//=============================================================================
// Added code to insert Filter.sv into the output path
//=============================================================================
	// The signals from the system to the filter.
	wire		          		pre_VGA_BLANK_N;
	wire		     [7:0]		pre_VGA_B;
	wire		     [7:0]		pre_VGA_G;
	wire		          		pre_VGA_HS;
	wire		     [7:0]		pre_VGA_R;
	wire		          		pre_VGA_SYNC_N;
	wire		          		pre_VGA_VS;
	// The signals from the filter to the VGA
	wire		          		post_VGA_BLANK_N;
	wire		     [7:0]		post_VGA_B;
	wire		     [7:0]		post_VGA_G;
	wire		          		post_VGA_HS;
	wire		     [7:0]		post_VGA_R;
	wire		          		post_VGA_SYNC_N;
	wire		          		post_VGA_VS;
	
	Filter #(.WIDTH(640), .HEIGHT(480))
		filter (.VGA_CLK(VGA_CLK),
					.iVGA_B(pre_VGA_B), .iVGA_G(pre_VGA_G), .iVGA_R(pre_VGA_R),
					.iVGA_HS(pre_VGA_HS), .iVGA_VS(pre_VGA_VS),
					.iVGA_SYNC_N(pre_VGA_SYNC_N), .iVGA_BLANK_N(pre_VGA_BLANK_N),
					.oVGA_B(post_VGA_B), .oVGA_G(post_VGA_G), .oVGA_R(post_VGA_R),
					.oVGA_HS(post_VGA_HS), .oVGA_VS(post_VGA_VS),
					.oVGA_SYNC_N(post_VGA_SYNC_N), .oVGA_BLANK_N(post_VGA_BLANK_N),
					
				   .KEY(KEY[1:0]), .SW(SW[8:0]));
					
	assign VGA_BLANK_N = post_VGA_BLANK_N;
	assign VGA_B = post_VGA_B;
	assign VGA_G = post_VGA_G;
	assign VGA_HS = post_VGA_HS;
	assign VGA_R = post_VGA_R;
	assign VGA_SYNC_N = post_VGA_SYNC_N;
	assign VGA_VS = post_VGA_VS;

//=============================================================================
// REG/WIRE declarations
//=============================================================================


wire	[15:0]SDRAM_RD_DATA;
wire			DLY_RST_0;
wire			DLY_RST_1;
wire			DLY_RST_2;

wire			SDRAM_CTRL_CLK;
wire        D8M_CK_HZ ; 
wire        D8M_CK_HZ2 ; 
wire        D8M_CK_HZ3 ; 

wire [7:0] RED   ; 
wire [7:0] GREEN  ; 
wire [7:0] BLUE 		 ; 
wire [12:0] VGA_H_CNT;			
wire [12:0] VGA_V_CNT;	

wire        READ_Request ;
wire 	[7:0] B_AUTO;
wire 	[7:0] G_AUTO;
wire 	[7:0] R_AUTO;
wire        RESET_N  ; 

wire        I2C_RELEASE ;  
wire        AUTO_FOC ; 
wire        CAMERA_I2C_SCL_MIPI ; 
wire        CAMERA_I2C_SCL_AF;
wire        CAMERA_MIPI_RELAESE ;
wire        MIPI_BRIDGE_RELEASE ;  
 
wire        LUT_MIPI_PIXEL_HS;
wire        LUT_MIPI_PIXEL_VS;
wire [9:0]  LUT_MIPI_PIXEL_D  ;
wire        MIPI_PIXEL_CLK_; 
wire [9:0]  PCK;
//=======================================================
// Structural coding
//=======================================================
//--INPU MIPI-PIXEL-CLOCK DELAY
CLOCK_DELAY  del1(  .iCLK (MIPI_PIXEL_CLK),  .oCLK (MIPI_PIXEL_CLK_ ) );


assign LUT_MIPI_PIXEL_HS=MIPI_PIXEL_HS;
assign LUT_MIPI_PIXEL_VS=MIPI_PIXEL_VS;
assign LUT_MIPI_PIXEL_D =MIPI_PIXEL_D ;

//------UART OFF --
assign UART_RTS =0; 
assign UART_TXD =0; 

//------ MIPI BRIGE & CAMERA RESET  --
assign CAMERA_PWDN_n  = 1; 
assign MIPI_CS_n      = 0; 
assign MIPI_RESET_n   = RESET_N ;

//------ CAMERA MODULE I2C SWITCH  --
assign I2C_RELEASE    = CAMERA_MIPI_RELAESE & MIPI_BRIDGE_RELEASE; 
assign CAMERA_I2C_SCL =( I2C_RELEASE  )?  CAMERA_I2C_SCL_AF  : CAMERA_I2C_SCL_MIPI ;   
 
//----- RESET RELAY  --		
RESET_DELAY			u2	(	
							.iRST  ( KEY[2] ),
                     .iCLK  ( CLOCK2_50 ),
							.oRST_0( DLY_RST_0 ),
							.oRST_1( DLY_RST_1 ),
							.oRST_2( DLY_RST_2 ),					
						   .oREADY( RESET_N)  
							
						);
 
//------ MIPI BRIGE & CAMERA SETTING  --  
MIPI_BRIDGE_CAMERA_Config    cfin(
                      .RESET_N           ( RESET_N ), 
                      .CLK_50            ( CLOCK2_50 ), 
                      .MIPI_I2C_SCL      ( MIPI_I2C_SCL ), 
                      .MIPI_I2C_SDA      ( MIPI_I2C_SDA ), 
                      .MIPI_I2C_RELEASE  ( MIPI_BRIDGE_RELEASE ),  
                      .CAMERA_I2C_SCL    ( CAMERA_I2C_SCL_MIPI ),
                      .CAMERA_I2C_SDA    ( CAMERA_I2C_SDA ),
                      .CAMERA_I2C_RELAESE( CAMERA_MIPI_RELAESE )
             );
				 
//------MIPI / VGA REF CLOCK  --
pll_test pll_ref(
	                   .inclk0 ( CLOCK3_50 ),
	                   .areset ( ~KEY[2]   ),
	                   .c0( MIPI_REFCLK    ) //20Mhz

    );
	 
//------MIPI / VGA REF CLOCK  -
VIDEO_PLL pll_ref1(
	                   .inclk0 ( CLOCK2_50 ),
	                   .areset ( ~KEY[2] ),
	                   .c0( VGA_CLK )        //25 Mhz	
    );	 
//------SDRAM CLOCK GENNERATER  --
sdram_pll u6(
		               .areset( 0 ) ,     
		               .inclk0( CLOCK_50 ),              
		               .c1    ( DRAM_CLK ),       //100MHZ   -90 degree
		               .c0    ( SDRAM_CTRL_CLK )  //100MHZ     0 degree 							
		              
	               );		
						
//------SDRAM CONTROLLER --
Sdram_Control	   u7	(	//	HOST Side						
						   .RESET_N     ( KEY[2] ),
							.CLK         ( SDRAM_CTRL_CLK ) , 
							//	FIFO Write Side 1
							.WR1_DATA    ( LUT_MIPI_PIXEL_D[9:0] ),
							.WR1         ( LUT_MIPI_PIXEL_HS & LUT_MIPI_PIXEL_VS ) ,
							
							.WR1_ADDR    ( 0 ),
                     .WR1_MAX_ADDR( 640*480 ),
						   .WR1_LENGTH  ( 256 ) , 
		               .WR1_LOAD    ( !DLY_RST_0 ),
							.WR1_CLK     ( MIPI_PIXEL_CLK_),

                     //	FIFO Read Side 1
						   .RD1_DATA    ( SDRAM_RD_DATA[9:0] ),
				        	.RD1         ( READ_Request ),
				        	.RD1_ADDR    (0 ),
                     .RD1_MAX_ADDR( 640*480 ),
							.RD1_LENGTH  ( 256  ),
							.RD1_LOAD    ( !DLY_RST_1 ),
							.RD1_CLK     ( VGA_CLK ),
											
							//	SDRAM Side
						   .SA          ( DRAM_ADDR ),
							.BA          ( DRAM_BA ),
							.CS_N        ( DRAM_CS_N ),
							.CKE         ( DRAM_CKE ),
							.RAS_N       ( DRAM_RAS_N ),
							.CAS_N       ( DRAM_CAS_N ),
							.WE_N        ( DRAM_WE_N ),
							.DQ          ( DRAM_DQ ),
							.DQM         ( DRAM_DQM  )
						   );	 	 
	 
//------ CMOS CCD_DATA TO RGB_DATA -- 

RAW2RGB_J				u4	(	
							.RST          ( pre_VGA_VS ),
							.iDATA        ( SDRAM_RD_DATA[9:0] ),

							//-----------------------------------
                     .VGA_CLK      ( VGA_CLK ),
                     .READ_Request ( READ_Request ),
                     .VGA_VS       ( pre_VGA_VS ),	
							.VGA_HS       ( pre_VGA_HS ), 
	                  			
							.oRed         ( RED  ),
							.oGreen       ( GREEN),
							.oBlue        ( BLUE )


							);		 
//------AOTO FOCUS ENABLE  --
AUTO_FOCUS_ON  vd( 
                      .CLK_50      ( CLOCK2_50 ), 
                      .I2C_RELEASE ( I2C_RELEASE ), 
                      .AUTO_FOC    ( AUTO_FOC )
               ) ;
					

//------AOTO FOCUS ADJ  --
FOCUS_ADJ adl(
                      .CLK_50        ( CLOCK2_50 ) , 
                      .RESET_N       ( I2C_RELEASE ), 
                      .RESET_SUB_N   ( I2C_RELEASE ), 
                      .AUTO_FOC      ( KEY[3] & AUTO_FOC ), 
                      .SW_Y          ( 0 ),
                      .SW_H_FREQ     ( 0 ),   
                      .SW_FUC_LINE   ( SW[9] ),   
                      .SW_FUC_ALL_CEN( SW[9] ),
                      .VIDEO_HS      ( pre_VGA_HS ),
                      .VIDEO_VS      ( pre_VGA_VS ),
                      .VIDEO_CLK     ( VGA_CLK ),
		                .VIDEO_DE      (READ_Request) ,
                      .iR            ( R_AUTO ), 
                      .iG            ( G_AUTO ), 
                      .iB            ( B_AUTO ), 
                      .oR            ( pre_VGA_R ) , 
                      .oG            ( pre_VGA_G ) , 
                      .oB            ( pre_VGA_B ) , 
                      
                      .READY         ( READY ),
                      .SCL           ( CAMERA_I2C_SCL_AF ), 
                      .SDA           ( CAMERA_I2C_SDA )
);

//------VGA Controller  --
VGA_Controller		u1	(	//	Host Side
							 .oRequest( READ_Request ),
							 .iRed    ( DISP_R    ),
							 .iGreen  ( DISP_G  ),
							 .iBlue   ( DISP_B   ),
							 
							 //	VGA Side
							 .oVGA_R  ( R_AUTO[7:0] ),
							 .oVGA_G  ( G_AUTO[7:0] ),
							 .oVGA_B  ( B_AUTO[7:0] ),
							 .oVGA_H_SYNC( pre_VGA_HS ),
							 .oVGA_V_SYNC( pre_VGA_VS ),
							 .oVGA_SYNC  ( pre_VGA_SYNC_N ),
							 .oVGA_BLANK ( pre_VGA_BLANK_N ),
							 //	Control Signal
							 .iCLK       ( VGA_CLK ),
							 .iRST_N     ( DLY_RST_2 ),
							 .H_Cont     ( VGA_H_CNT ),						
						    .V_Cont     ( VGA_V_CNT )								
		);	

wire  [7:0]   DISP_R;
wire  [7:0]   DISP_G;
wire  [7:0]   DISP_B;	

assign DISP_R = SW[8] ? RED   :    //  30% Gray
                SW[7] ? BLUE  :    //  Black
					 SW[6] ? GREEN :    //	GRAY
                        RED  ;     //  Color
								 
assign DISP_G = SW[8] ? RED   :    //  30% Gray
                SW[7] ? BLUE  :    //  Black
                SW[6] ? GREEN :    //  GRAY
								GREEN;     //  Color
					 
assign DISP_B = SW[8] ? RED   :    //  30% Gray
                SW[7] ? BLUE  : 	  //  Black
                SW[6] ? GREEN :    //  GRAY
								BLUE;      //  Color


////------VS FREQUENCY TEST = 60HZ --
//							
//FpsMonitor uFps( 
//	   .clk50    ( CLOCK2_50 ),
//	   .vs       ( LUT_MIPI_PIXEL_VS ),
//	
//	   .fps      (),
//	   .hex_fps_h( HEX1 ),
//	   .hex_fps_l( HEX0 )
//);
//

////--LED DISPLAY--
//CLOCKMEM  ck1 ( .CLK(VGA_CLK )   ,.CLK_FREQ  (25000000  ) , . CK_1HZ (D8M_CK_HZ   )  )        ;//25MHZ
//CLOCKMEM  ck2 ( .CLK(MIPI_REFCLK   )   ,.CLK_FREQ  (20000000   ) , . CK_1HZ (D8M_CK_HZ2  )  ) ;//20MHZ
//CLOCKMEM  ck3 ( .CLK(MIPI_PIXEL_CLK_)   ,.CLK_FREQ  (25000000  ) , . CK_1HZ (D8M_CK_HZ3  )  )  ;//25MHZ


//assign LEDR = { D8M_CK_HZ ,D8M_CK_HZ2,D8M_CK_HZ3 ,5'h0,CAMERA_MIPI_RELAESE ,MIPI_BRIDGE_RELEASE  } ; 

endmodule

module clock_divider (clock, divided_clocks);
	input logic clock;
	output logic [31:0] divided_clocks;

	initial begin
		divided_clocks <= 0;
	end

	always_ff @(posedge clock) begin
		divided_clocks <= divided_clocks + 1;
   end

endmodule

